*先要Google以下学习的知识点: VGA字符单元 / VGA character cells, 屏幕偏移 / screen offset*

> 同样，Makefile需要修改

* VGA字符模式（VGA text mode）是打印字符到屏幕的一种简单方式。

字符单元（character cell）
* 为了在VGA字符模式向屏幕打印字符，我们必须将它写入硬件提供的VGA字符缓冲区（VGA text buffer）。
* 通常状况下，VGA字符缓冲区是一个25行、80列的二维数组，它的内容将被实时渲染到屏幕。这个数组的元素被称作字符单元（character cell）

**目标: 屏幕上打印**

最后，我们将能够在屏幕上输出文本。 本课程包含比平时更多的代码，所以让我们逐步进行。

打开 `drivers/screen.h` ，您会看到我们为VGA卡驱动程序定义了一些常量，并定义了三个公共函数，
- 一个用于清除屏幕，
- 另一个用于编写字符串，
- 著名的`kprint`用于内核打印

现在打开`drivers / screen.c`。 它从声明私有帮助器函数开始，我们将使用它们来帮助我们的内核API kprint函数。

在上一课中，我们学习了两个I/O端口访问例程：`get` 和 `set_cursor_offset()`。

然后是直接操作视频内存的函数，`print_char()`。

最后，有三个小的辅助函数可以将行和列转换为偏移量，反之亦然。

kprint_at
---------

这表示我们将在当前光标位置打印字符串。

用值可以为`-1`的`col`和`row`的来调用`kprint_at`，这表示我们将在当前光标位置打印字符串。

它首先为col/row和offset设置三个变量。 然后，通过`char*`进行迭代，并使用当前坐标调用`print_char()`。

注意，`print_char`本身返回下一个光标位置的偏移量，我们将其重用于下一个循环。

`kprint` 是 `kprint_at` 的简单封装函数


print_char
----------

像`kprint_at`一样，`print_char`允许cols/rows为`-1`。 在这种情况下，它使用`ports.c`程序从硬件中检索光标位置。

`print_char`也处理换行符。 在这种情况下，我们会将光标偏移量定位到下一行的第0列。

请记住，VGA单元占用两个字节，一个用于字符本身，另一个用于属性。

kernel.c
--------

我们的新内核终于可以打印字符串了。

它测试字符定位是否正确，跨越多行，换行，最后尝试在屏幕边界之外书写。 那会发生什么呢？

在下一课中，我们将学习如何滚动屏幕。
