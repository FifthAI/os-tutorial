*前提基础，自行百度，Google: GDT*

> *全局描述表(GDT Global Descriptor Table):在保护模式下一个重要的数据结构。*  
> GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，CPU必须知道GDT的入口，也就是基地址放在哪里，  
> 所以Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，  
> 从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。

**Goal: 编写GDT**

还记得第6课中的段内存吗？ 偏移量用左移地址以解决间接的额外问题。

在32位模式下，段的工作方式有所不同。 现在，偏移量成为GDT中段描述符（SD）的索引。 该描述符定义了基地址（32位），大小（20位）和一些标志，例如只读，权限等。为了增加混乱，将拆分数据结构，因此请打开os-dev.pdf文件并签出 有关GDT的信息，请参阅第34页或Wikipedia页面。

编写GDT的最简单方法是定义两个段，一个段用于代码，另一段用于数据。 

这些可以重叠，这意味着没有内存保护，但是足以启动，我们稍后将使用更高的语言解决此问题。

出于好奇，第一个GDT条目必须为`0x00` ，以确保程序员在管理地址时不会犯任何错误。

此外，CPU无法直接加载GDT地址，它需要一个称为“ GDT描述符”的元结构，其大小为实际GDT的大小（16b）和地址（32b）。 它被`lgdt`操作指令加载。

让我们直接跳到汇编中的GDT代码。 同样，要了解所有段标志，请参阅os-dev.pdf文档。 本课程的理论非常复杂。

在下一课中，我们将切换到32位保护模式，并从这些课中测试我们的代码。